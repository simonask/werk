use futures::channel::oneshot;
use werk_fs::{Absolute, SymPath};
use werk_util::Symbol;

use crate::{Error, ir};

use super::BuildStatus;

pub enum TaskStatus {
    Built(Result<BuildStatus, Error>),
    Pending(Vec<oneshot::Sender<Result<BuildStatus, Error>>>),
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TaskId {
    Task(Symbol),
    // TODO: When recipes can build multiple files, this needs to change to some
    // ID that encapsulates the "recipe instance" rather than the path of a
    // single target.
    Build(Absolute<SymPath>),
}

impl TaskId {
    pub fn command(s: impl Into<Symbol>) -> Self {
        let name = s.into();
        debug_assert!(!name.as_str().starts_with('/'));
        TaskId::Task(name)
    }

    pub fn build(p: impl AsRef<Absolute<werk_fs::Path>>) -> Self {
        TaskId::Build(Absolute::symbolicate(p))
    }

    pub fn try_build<P>(p: P) -> Result<Self, P::Error>
    where
        P: TryInto<Absolute<werk_fs::PathBuf>>,
    {
        let path = p.try_into()?;
        Ok(TaskId::build(path))
    }

    #[inline]
    #[must_use]
    pub fn is_command(&self) -> bool {
        matches!(self, TaskId::Task(_))
    }

    #[inline]
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            TaskId::Task(task) => task.as_str(),
            TaskId::Build(build) => build.as_inner().as_str(),
        }
    }

    #[inline]
    #[must_use]
    pub fn as_path(&self) -> Option<&Absolute<werk_fs::Path>> {
        if let TaskId::Build(build) = self {
            Some(build.as_path())
        } else {
            None
        }
    }

    #[inline]
    #[must_use]
    pub fn short_name(&self) -> &'static str {
        match self {
            TaskId::Task(task) => task.as_str(),
            TaskId::Build(path) => {
                let Some((_prefix, filename)) = path
                    .as_inner()
                    .as_str()
                    .rsplit_once(werk_fs::Path::SEPARATOR)
                else {
                    // The path is absolute.
                    unreachable!()
                };
                filename
            }
        }
    }
}

impl std::fmt::Display for TaskId {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(self.as_str())
    }
}

pub enum TaskSpec<'a> {
    Recipe(ir::RecipeMatch<'a>),
    CheckExists(Absolute<werk_fs::PathBuf>),
    /// Check if the file exists, but don't emit an error if it doesn't. This
    /// applies to dependencies discovered through depfiles, where the depfile
    /// may be outdated (from a previous build).
    ///
    /// If the file does not exist, the task will be considered outdated.
    CheckExistsRelaxed(Absolute<werk_fs::PathBuf>),
}

impl TaskSpec<'_> {
    #[must_use]
    pub fn to_task_id(&self) -> TaskId {
        match self {
            TaskSpec::Recipe(ir::RecipeMatch::Build(build_recipe_match)) => {
                TaskId::build(build_recipe_match.target_file.clone())
            }
            TaskSpec::Recipe(ir::RecipeMatch::Task(task_recipe_match)) => {
                TaskId::command(task_recipe_match.name)
            }
            TaskSpec::CheckExists(path_buf) | TaskSpec::CheckExistsRelaxed(path_buf) => {
                TaskId::build(path_buf.clone().into_boxed_path())
            }
        }
    }
}

pub enum DepfileSpec<'a> {
    /// The depfile is explicitly generated by a recipe.
    Recipe(ir::BuildRecipeMatch<'a>),
    /// The depfile is implicitly generated by the associated command recipe.
    ImplicitlyGenerated(Absolute<werk_fs::PathBuf>),
}
