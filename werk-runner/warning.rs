use werk_fs::Absolute;
use werk_parser::parser::Span;
use werk_util::{AnnotateLevelExt as _, DiagnosticFileId, Level};

#[derive(Clone, Debug, thiserror::Error)]
pub enum Warning {
    #[error("no patterns in scope containing a stem `%`")]
    NoPatternStem(Span),
    #[error("no implicit value in scope")]
    NoImpliedValue(Span),
    #[error("ignoring unresolved path")]
    IgnoringUnresolvedPath(Span, String),
    #[error("ignoring non-absolute OS path")]
    IgnoringNonAbsolutePath(Span, std::path::PathBuf),
    #[error("ignoring path outside output directory")]
    IgnoringPathOutsideOutputDirectory(Span, Absolute<std::path::PathBuf>),
    #[error("ignoring file not found")]
    IgnoringFileNotFound(Span, Absolute<std::path::PathBuf>),
    #[error("depfile was not generated by the recipe, and there was no rule to generate it")]
    DepfileNotGenerated(Span, Absolute<std::path::PathBuf>),
    #[error("{1}")]
    WarningExpression(Span, String),
    #[error("unused define `{0}`")]
    UnusedDefine(String),
    #[error("output directory changed; was `{0}`, is now `{1}`")]
    OutputDirectoryChanged(Absolute<std::path::PathBuf>, Absolute<std::path::PathBuf>),
}

impl werk_util::AsDiagnostic for Warning {
    fn as_diagnostic(&self) -> werk_util::Diagnostic {
        let level = Level::Warning;
        let file_id = DiagnosticFileId::default(); // TODO

        match self {
            Warning::NoPatternStem(span) => level
                .diagnostic("W0010")
                .snippet(file_id.snippet(Some(level.annotation(
                    *span,
                    "this string uses `%`, but it will evaluate to an empty string",
                ))))
                .footer("perhaps you meant to escape the literal character: `\\%`"),
            Warning::NoImpliedValue(span) => level
                .diagnostic("W0011").snippet(file_id.snippet(Some(level.annotation(
                *span,
                "this string uses the implicit value `{}` or `<>`, but the current expression has no implicit value",
            )))).footer("use an expression chain `lhs | rhs` to introduce an implicit value"),
            Warning::IgnoringUnresolvedPath(span, path) => level
                .diagnostic("W0020")
                .snippet(file_id.snippet(Some(level.annotation(
                    *span,
                    format!("path `{path}` is not resolved"),
                )))),
            Warning::IgnoringNonAbsolutePath(span, path_buf) => level
                .diagnostic("W0021")
                .snippet(file_id.snippet(Some(level.annotation(
                    *span,
                    format!("path `{}` is not absolute", path_buf.display()),
                ))))
                .footer("use \"<...>\" to convert abstract paths to native OS paths"),
            Warning::IgnoringPathOutsideOutputDirectory(span, absolute) => level
                .diagnostic("W0022")
                .snippet(file_id.snippet(Some(level.annotation(
                    *span,
                    format!("path `{}` is outside the output directory", absolute.display()),
                ))))
                .footer("use \"<...:out-dir>\" to unambiguously produce an absolute path in the output directory"),
            Warning::IgnoringFileNotFound(span, absolute) => level
                .diagnostic("W0023")
                .snippet(file_id.snippet(Some(level.annotation(
                    *span,
                    format!("file `{}` not found", absolute.display()),
                )))),
            Warning::DepfileNotGenerated(span, absolute) => level
                .diagnostic("W0030")
                .snippet(file_id.snippet(Some(level.annotation(
                    *span,
                    format!("expected this rule to write `{}`", absolute.display()),
                ))))
                .footer(
                    "pass `-MMD`, `-MF`, or similar flags to your compiler to implicitly generate a depfile",)
                    .footer(
                    "or add a recipe to generate the depfile"
                ),
            Warning::WarningExpression(span, message) => level
                .diagnostic("W9999")
                .snippet(file_id.snippet(Some(level.annotation(*span, message.clone())))),
            Warning::UnusedDefine(key) => level
                .diagnostic("W1000")
                .footer(format_args!("no `config` statement exists with the name `{key}`"))
                .footer("maybe a `let` statement should be changed to a `config` statement?"),
            Warning::OutputDirectoryChanged(..) => level
                .diagnostic("W1001")
        }.title(self) // Use Display impl from thiserror
    }
}
