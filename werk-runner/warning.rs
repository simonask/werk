use annotate_snippets::{AnnotationKind, Snippet};
use werk_fs::Absolute;
use werk_util::{DiagnosticSourceMap, DiagnosticSpan, Level};

#[derive(Clone, Debug, thiserror::Error)]
pub enum Warning {
    #[error("no patterns in scope containing a stem `%`")]
    NoPatternStem(DiagnosticSpan),
    #[error("no implicit value in scope")]
    NoImpliedValue(DiagnosticSpan),
    #[error("ignoring unresolved path")]
    IgnoringUnresolvedPath(DiagnosticSpan, String),
    #[error("ignoring non-absolute OS path")]
    IgnoringNonAbsolutePath(DiagnosticSpan, std::path::PathBuf),
    #[error("ignoring path outside output directory")]
    IgnoringPathOutsideOutputDirectory(DiagnosticSpan, Absolute<std::path::PathBuf>),
    #[error("ignoring file not found")]
    IgnoringFileNotFound(DiagnosticSpan, Absolute<std::path::PathBuf>),
    #[error("depfile was not generated by the recipe, and there was no rule to generate it")]
    DepfileNotGenerated(DiagnosticSpan, Absolute<std::path::PathBuf>),
    #[error("{1}")]
    WarningExpression(DiagnosticSpan, String),
    #[error("unused define `{0}`")]
    UnusedDefine(String),
    #[error("output directory changed; was `{0}`, is now `{1}`")]
    OutputDirectoryChanged(Absolute<std::path::PathBuf>, Absolute<std::path::PathBuf>),
    #[error("one or more child processes did not stop when asked, and may be left as zombies")]
    ZombieChild,
}

impl Warning {
    #[must_use]
    pub fn id(&self) -> &'static str {
        match self {
            Warning::NoPatternStem(_) => "W0010",
            Warning::NoImpliedValue(_) => "W0011",
            Warning::IgnoringUnresolvedPath(_, _) => "W0020",
            Warning::IgnoringNonAbsolutePath(_, _) => "W0021",
            Warning::IgnoringPathOutsideOutputDirectory(_, _) => "W0022",
            Warning::IgnoringFileNotFound(_, _) => "W0023",
            Warning::DepfileNotGenerated(_, _) => "W0030",
            Warning::WarningExpression(_, _) => "W9999",
            Warning::UnusedDefine(_) => "W1000",
            Warning::OutputDirectoryChanged(..) => "W1001",
            Warning::ZombieChild => "W1002",
        }
    }

    #[must_use]
    pub fn span(&self) -> Option<DiagnosticSpan> {
        match self {
            Warning::NoPatternStem(span)
            | Warning::NoImpliedValue(span)
            | Warning::IgnoringUnresolvedPath(span, _)
            | Warning::IgnoringNonAbsolutePath(span, _)
            | Warning::IgnoringPathOutsideOutputDirectory(span, _)
            | Warning::IgnoringFileNotFound(span, _)
            | Warning::DepfileNotGenerated(span, _)
            | Warning::WarningExpression(span, _) => Some(*span),
            Warning::UnusedDefine(_)
            | Warning::OutputDirectoryChanged(..)
            | Warning::ZombieChild => None,
        }
    }
}

impl werk_util::AsDiagnostic for Warning {
    fn as_diagnostic<'a>(
        &'a self,
        source_map: &'a dyn DiagnosticSourceMap,
    ) -> Vec<annotate_snippets::Group<'a>> {
        let title = Level::WARNING.primary_title(self.to_string()).id(self.id());
        let span = self.span();
        let source = span.map(|span| source_map.get_source(span.file).expect("invalid file ID"));
        let snippet = source.map(|source| Snippet::source(source.source).path(source.file));

        let group = match self {
            Warning::NoPatternStem(span) => {
                title.element(snippet.unwrap().annotation(AnnotationKind::Primary.span(span.span.into()).label("this string uses `%`, but it will evaluate to an empty string"))).element(Level::HELP.message("perhaps you meant to escape the literal character: `\\%`"))
            },
            Warning::NoImpliedValue(span) =>  {
                title.element(snippet.unwrap().annotation(AnnotationKind::Primary.span(span.span.into()).label("this string uses the implicit value `{}` or `<>`, but the current expression has no implicit value"))).element(Level::HELP.message("use an expression chain `lhs | rhs` to introduce an implicit value"))
            }
            Warning::IgnoringUnresolvedPath(span, path) => {
                title.element(snippet.unwrap().annotation(AnnotationKind::Primary.span(span.span.into()).label(format!("path `{path}` is not resolved"))))
            }
            Warning::IgnoringNonAbsolutePath(span, path_buf) => {
                title.element(snippet.unwrap().annotation(AnnotationKind::Primary.span(span.span.into()).label(format!("path `{}` is not absolute", path_buf.display())))).element(Level::HELP.message("use \"<...>\" to convert abstract paths to native OS paths"))
            }
            Warning::IgnoringPathOutsideOutputDirectory(span, absolute) => {
                title.element(snippet.unwrap().annotation(AnnotationKind::Primary.span(span.span.into()).label(format!("path `{}` is outside the output directory", absolute.display())))).element(Level::HELP.message("use \"<...:out-dir>\" to unambiguously produce an absolute path in the output directory"))
            }
            Warning::IgnoringFileNotFound(span, absolute) => {
                title.element(snippet.unwrap().annotation(AnnotationKind::Primary.span(span.span.into()).label(format!("file `{}` not found", absolute.display()))))
            }
            Warning::DepfileNotGenerated(span, absolute) => {
                title.element(snippet.unwrap().annotation(AnnotationKind::Primary.span(span.span.into()).label(format!("depfile `{}` was not generated", absolute.display()))))
                    .element(Level::HELP.message("pass `-MMD`, `-MF`, or similar flags to your compiler to implicitly generate a depfile, or add a recipe to generate the depfile"))
            }
            Warning::WarningExpression(span, message) => {
                title.element(snippet.unwrap().annotation(AnnotationKind::Primary.span(span.span.into()).label(message)))
            }
            Warning::UnusedDefine(key) => {
                title.element(Level::HELP.message(format!("no `config` statement exists with the name `{key}`")))
                    .element(Level::HELP.message("maybe a `let` statement should be changed to a `config` statement?"))
            }

            Warning::OutputDirectoryChanged(..) | Warning::ZombieChild => annotate_snippets::Group::with_title(title),
        };

        vec![group]
    }
}
